using System;

namespace OpenHFT.Core.Orders;

/// <summary>
/// Defines the source of an order, used for ID generation and tracking.
/// </summary>
public enum OrderSource : long
{
    /// <summary>
    /// Orders generated by automated strategies (Quoting, Hedging, etc.).
    /// </summary>
    NonManual = 0, // We can use the 0 range for the most common type.

    /// <summary>
    /// Orders placed manually through a UI or external command.
    /// Uses the most significant bit to distinguish it.
    /// </summary>
    Manual = 1L << 62 // Use bit 62, leaving bit 63 for future use (e.g., negative numbers).
}

public interface IClientIdGenerator
{
    /// <summary>
    /// Generates the next unique client order ID for a given source.
    /// </summary>
    long NextId(OrderSource source);
}

public class ClientIdGenerator : IClientIdGenerator
{
    // A single, thread-safe counter for the unique part of the ID.
    // Initialized with milliseconds since Unix epoch to ensure uniqueness across restarts.
    private static long _sequenceCounter = (long)(DateTime.UtcNow - DateTime.UnixEpoch).TotalMilliseconds;

    public long NextId(OrderSource source)
    {
        // Atomically increment the sequence.
        long sequence = Interlocked.Increment(ref _sequenceCounter);

        // Combine the source flag with the unique sequence.
        // The bitwise OR operation adds the source flag to the sequence.
        return (long)source | sequence;
    }

    /// <summary>
    /// Determines if a client order ID originated from a manual source.
    /// </summary>
    public static bool IsManualOrder(long clientOrderId)
    {
        // Check if the manual order flag (bit 62) is set.
        return (clientOrderId & (long)OrderSource.Manual) != 0;
    }
}